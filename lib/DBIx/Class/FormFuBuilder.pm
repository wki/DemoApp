package DBIx::Class::FormFuBuilder;
use strict;
use warnings;

# use base 'DBIx::Class';

=head1 NAME

DBIx::Class::FormFuBuilder

=head1 SYNOPSIS

    # inside your Model class:
    package YourApp::Model::DB;
    ...
    DBIx::Class->load_components('FormFuBuilder');
    
    
    # inside your result classes do this:
    package DemoApp::Schema::Result::Product;
    ...
    __PACKAGE__->form_fu_extra(column_name => {...});
    
    
    # at any place you need a form
    my $form = $result_set->generate_form_fu({...});

more examples to come!

=head1 DESCRIPTION


=head1 METHODS

=cut

=head2 form_fu_extras

specify some extra(s) that get into the {extra}->{form_fu} hash of a column

meaningful things could be:

=over 

=item title

=item label

=item constraints

=item filters

=back

=cut

sub form_fu_extra {
    my $self = shift;
    my $column_name = shift;
    my $args = ref($_[0]) eq 'HASH' ? shift : { @_ };
    
    $self->column_info($column_name)->{extras}->{formfu} = $args;
}

=head2 generate_form_fu

generate a form from a resultset including all joined tables

additionally a hash or a hashref with args may be added. Meaningful keys could be:

=over

=item action

=item constraints

=item indicator

if an indicator is given but no submit field present, it will get autogenerated at the end of the form

=item auto_fieldset

=item auto_constraint_class

=item attributes

=item elements

these elements will go to the beginning of the form

=item append

this is an additional element-array inserted at the end of the form

=back

=cut

sub generate_form_fu {
    my $rs = shift;
    my %args = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
    
    die 'only usable on classes derieved from "DBIx::Class::ResultSet"'
        unless $rs->isa('DBIx::Class::ResultSet');
    
    my $result_source = $rs->result_source;
    my $cols = join(', ', $result_source->columns);
    
    ### FIXME: stringification has a strange side-effect.
    warn "calling generate_form_fu with $rs / class=$result_source, cols=$cols";
    
    #
    # build form scaffolding merging singular things into plural...
    #
    my $append = delete $args{append};
    $args{elements} = [] if (ref($args{elements}) ne 'ARRAY');
    
    foreach my $s qw(constraint filter) {
        my $p = "${s}s";
        $args{$p} = [
            ($args{$s} 
             ? ref($args{$s}) eq 'ARRAY' ? @{$args{$s}} : $args{$s}
             : ()),
            ($args{$p} 
             ? ref($args{$p}) eq 'ARRAY' ? @{$args{$p}} : $args{$p}
             : ()),
        ];
        delete $args{$s};
    }
    my %form = (
        attributes => {},
        %args,
    );
    
    # warn "form: " . Data::Dumper->Dump([\%form], ['form']);
    
    #
    # add elements
    #
    $rs->_add_elements($result_source => $form{elements},
                       $rs->{_attrs}->{alias} || 'me',
                       @{$rs->{_attrs}->{select}} );

    push @{$form{elements}}, (ref($append) eq 'ARRAY' ? (@{$append}) : $append)
        if ($append);

    if ($args{indicator}) {
        push @{$form{elements}}, {
            type => 'Submit',
            name => $args{indicator},
            value => $args{indicator},
            label => ' ',
        };
    }
    
    #
    # done :-)
    #
    return \%form;
}

#
# add all fields from a list starting with alias
#
sub _add_elements {
    my $rs = shift;
    my $result_source = shift;
    my $elements = shift;
    my $alias = shift;
    my @columns = @_;
    
    warn "add elements: @columns...";
    
    #
    # add hidden ID for primary columns
    #
    my %is_primary = ();
    foreach my $primary_col ($result_source->primary_columns) {
        $is_primary{$primary_col} = 1;
        push @{$elements}, {
            type => 'Hidden',
            name => $primary_col,
        };
    }
    
    #
    # determine relationships
    #
    my @relationships = $result_source->relationships;
    my %has_one;  # my column => foreign result source class
    my %has_many; # relationship_name => 1
    foreach my $rel (@relationships) {
        my $rel_info = $result_source->relationship_info($rel);
        my @rel_fields = map {my $x = $_; $x =~ s{\A self [.]}{}xms; $x;}
                         grep {m{\A self [.]}xms}
                         (%{$rel_info->{cond}});
        if (scalar(@rel_fields) != 1) {
            #
            # Houston - we have a problem. We only can handle 1 field...
            #
        } elsif ($rel_info->{attrs}->{is_foreign_key_constraint}) {
            #
            # looks like a has_one relationship
            #
            $has_one{$rel_fields[0]} = $rel_info;
        } elsif ($is_primary{$rel_fields[0]}) {
            #
            # Looks like a has_many relationship
            #
            $has_many{$rel} = $rel_info;
        } else {
            #
            # TODO: find a condition for many_to_many
            #
        }
    }
    
    #
    # loop over fields
    #
    foreach my $column_with_alias (@columns) {
        # filter out columns we do not want...
        next if ($column_with_alias !~ m{\A $alias [.]}xms);
        
        my $column = $column_with_alias;
        $column =~ s{\A $alias [.]}{}xms;
        next if ($is_primary{$column});
        
        # get the column's info
        my $info = $result_source->column_info($column);
        
        # OK we got a field left to generate
        my %field = (
            name        => $column,
            label       => ucfirst($column),
            type        => 'Text',
            constraints => [],
            filters     => [],
            
            # %{$info->{extras}->{formfu} || {}},
        );
        if (exists($info->{extras}->{formfu})) {
            # poor man's deep copy...
            foreach my $key (%{$info->{extras}->{formfu}}) {
                my $value = $info->{extras}->{formfu}->{$key};
                if (!ref($value)) {
                    $field{$key} = $value;
                } elsif (ref($value) eq 'HASH') {
                    $field{$key} = { %{$value} };
                } elsif (ref($value) eq 'ARRAY') {
                    $field{$key} = [ @{$value} ];
                }
            }
        }
        
        if (exists($has_one{$column})) {
            #
            # has-one relation
            #
            my $source = $has_one{$column}->{source};
            
            $field{type} = 'Select';
            if ($info->{is_nullable}) {
                $field{empty_first} = 1;
                $field{empty_first_label} = '- none -';
            }
            my $label_column;
            if ($source->can('name')) {
                $label_column = 'name';
            } else {
                # find first non-index column
                my %is_prim = ( map {($_ => 1)} ($source->primary_columns) );
                foreach my $col (grep {!$is_prim{$_}} $source->columns) {
                    $label_column = $col;
                    last;
                }
            }
            $field{model_config} = {
                resultset    => $has_one{$column}->{source},
                label_column => $label_column,
                attributes   => {
                    order_by => $label_column,
                },
            };
            #delete $field{constraints};
            #delete $field{filters};
        } else {
            #
            # simple field
            #
            if (!$info->{is_nullable}) {
                push @{$field{constraints}}, {type => 'Required'};
            }
            if ($info->{data_type} eq 'numeric') {
                push @{$field{constraints}}, {type => 'Number'};
            }
        }
        
        push @{$elements}, \%field;
    }

    #
    # finally add all has_many relationships
    #
    foreach my $from (@{$rs->{_attrs}->{from}}) {
        next if (ref($from) ne 'ARRAY');
        my ($rel_name) = grep {exists($has_many{$_})} keys(%{$from->[0]});
        next if (!$rel_name);
    
        # we found a has-many relation we would join in a select
        my %repeatable = (
            type         => 'Repeatable',
            nested_name  => $rel_name,
            counter_name => "${rel_name}_count",
            model_config => {
                empty_rows   => 1,
                new_rows_max => 10,
            },
            elements => [],
        );
        
        my @repeat_columns;
        foreach my $column (@columns) {
            next if ($column !~ m{\A $rel_name [.]}xms);
            my $short_col = $column;
            $short_col =~ s{\A \w+ [.]}{}xms;
            next if (grep {m{\A foreign [.] $short_col}xms} %{$has_many{$rel_name}->{cond}});
            push @repeat_columns, $column;
        }
        $rs->_add_elements($has_many{$rel_name}->{source} => $repeatable{elements},
                           $rel_name, @repeat_columns);
        
        push @{$elements}, \%repeatable;
        
        push @{$elements}, {
            type => 'Hidden',
            name => "${rel_name}_count",
        };
    }

}

#
# helper: set a filter or a constraint
#
sub _set_thing {
    my $field = shift;
    my $thing = shift; # 'contraint(s)' or 'filter(s)'
    my $info  = shift;
    
    $thing .= 's' if (exists($field->{"${thing}s"}));
    return if (!exists($field->{$thing}));

    ### TODO: clever handle singular/plural things
    ### TODO: clever fill-in things without generating duplicates
}

=head1 AUTHOR

Wolfgang Kinkeldei, E<lt>wolfgang@kinkeldei.deE<gt>

=head1 LICENSE

This library is free software, you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

1;

